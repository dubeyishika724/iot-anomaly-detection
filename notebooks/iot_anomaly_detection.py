# -*- coding: utf-8 -*-
"""IoT_Anomaly_Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sGjgVdOj81xf44VNehpMizMF4d2YS1O-
"""

import pandas as pd
import numpy as np

# Visualization
import matplotlib.pyplot as plt

# Preprocessing
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

# Anomaly Detection Models
from sklearn.ensemble import IsolationForest
from sklearn.svm import OneClassSVM
from sklearn.neighbors import LocalOutlierFactor

# Evaluation
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

# Autoencoder
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense

df = pd.read_csv('synthetic_iot_dataset (1).csv')
df.head()

df.info()
df.describe()

# Data preprocessing
# Check missing values
df.isnull().sum()

# Select features
features = ['Temperature', 'Humidity', 'Battery_Level']
X = df[features]

# Ground truth (if available)
y = df['Anomaly']

# Train-test-split
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.3, random_state=42
)

# Isolation forest model
iso_forest = IsolationForest(contamination=0.05, random_state=42)
iso_forest.fit(X_train)

y_pred_if = iso_forest.predict(X_test)
y_pred_if = np.where(y_pred_if == -1, 1, 0)

# One class SVM Model
ocsvm = OneClassSVM(kernel='rbf', nu=0.05, gamma='scale')
ocsvm.fit(X_train)

y_pred_svm = ocsvm.predict(X_test)
y_pred_svm = np.where(y_pred_svm == -1, 1, 0)

# LOF
lof = LocalOutlierFactor(n_neighbors=20, contamination=0.05)
y_pred_lof = lof.fit_predict(X_test)
y_pred_lof = np.where(y_pred_lof == -1, 1, 0)

#Autoencoder
input_dim = X_train.shape[1]

input_layer = Input(shape=(input_dim,))
encoded = Dense(8, activation='relu')(input_layer)
encoded = Dense(4, activation='relu')(encoded)

decoded = Dense(8, activation='relu')(encoded)
decoded = Dense(input_dim, activation='linear')(decoded)

autoencoder = Model(inputs=input_layer, outputs=decoded)
autoencoder.compile(optimizer='adam', loss='mse')

autoencoder.fit(
    X_train, X_train,
    epochs=50,
    batch_size=32,
    validation_split=0.1,
    verbose=0
)

#AutoencoderAnomaly detection model
reconstruction = autoencoder.predict(X_test)
mse = np.mean(np.power(X_test - reconstruction, 2), axis=1)

threshold = np.percentile(mse, 95)
y_pred_ae = np.where(mse > threshold, 1, 0)

# Model Evaluation function
def evaluate_model(y_true, y_pred, model_name):
    print(f"\n{model_name}")
    print("Accuracy:", accuracy_score(y_true, y_pred))
    print("Precision:", precision_score(y_true, y_pred))
    print("Recall:", recall_score(y_true, y_pred))
    print("F1 Score:", f1_score(y_true, y_pred))

#  Evaluate all models
evaluate_model(y_test, y_pred_if, "Isolation Forest")
evaluate_model(y_test, y_pred_svm, "One-Class SVM")
evaluate_model(y_test, y_pred_lof, "Local Outlier Factor")
evaluate_model(y_test, y_pred_ae, "Autoencoder")

#  Visualize anomalies
df['Predicted_Anomaly'] = iso_forest.predict(X_scaled)
df['Predicted_Anomaly'] = np.where(df['Predicted_Anomaly'] == -1, 1, 0)

normal = df[df['Predicted_Anomaly'] == 0]
anomaly = df[df['Predicted_Anomaly'] == 1]

plt.figure(figsize=(12,6))
plt.scatter(normal.index, normal['Temperature'], label='Normal', alpha=0.6)
plt.scatter(anomaly.index, anomaly['Temperature'], label='Anomaly', color='red')
plt.title("Anomaly Detection Visualization (Temperature)")
plt.xlabel("Time Index")
plt.ylabel("Temperature")
plt.legend()
plt.show()

#  Graphical comparision of models
models = ['Isolation Forest', 'One-Class SVM', 'LOF', 'Autoencoder']
f1_scores = [
    f1_score(y_test, y_pred_if),
    f1_score(y_test, y_pred_svm),
    f1_score(y_test, y_pred_lof),
    f1_score(y_test, y_pred_ae)
]

plt.figure(figsize=(8,5))
plt.bar(models, f1_scores)
plt.title("F1-Score Comparison of Anomaly Detection Models")
plt.ylabel("F1 Score")
plt.show()

df.to_csv("anomaly_detection_results.csv", index=False)